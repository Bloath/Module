/* Includes ------------------------------------------------------------------*/
#include "string.h"

#include "../Module/Common/Malloc.h"
#include "SimpleBuffer.h"
#include "SimpleBuffer_Handle.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
void TxBlockErrorHandle(TxBlockError error);

/* Private functions ---------------------------------------------------------*/
/*********************************************************************************************

  * @brief  接收单个字节
  * @param  data:       接收的单字节
  * @param  rxBuffer   接收缓冲结构体
  * @retval 无
  * @remark 

  ********************************************************************************************/
void ReceiveSingleByte(uint8_t data, RxBufferTypeDef *rxBuffer)
{
  rxBuffer->buffer[rxBuffer->count] = data;         //填入缓冲 
  rxBuffer->count ++;                               //计数器递增
  if(rxBuffer->count >= BUFFER_LENGTH)
  { BufferOverFlow(); }
}

/*********************************************************************************************

  * @brief  将缓冲内的数据填写到报文队列中
  * @param  rxBlockList：   接收缓冲结构体
            packet：   要填入接收块的数据包指针
            len；长度
  * @retval 无
  * @remark 返回填充队列号，如果为0xFFFF则为失败

  ********************************************************************************************/
uint16_t FillRxBlock( RxBlockTypeDef *rxBlock, uint8_t *packet, uint16_t Len)
{
  uint8_t i = 0;
  
  if(Len == 0)
  { return 0xFFFF; }
  
  /* 找到空闲缓冲，填入 */
  for(i=0; i<RX_BLOCK_COUNT; i++)
  {
    if(!(rxBlock[i].flag & RX_FLAG_USED))                                      //查找空闲报文队列
    {
      rxBlock[i].flag |= RX_FLAG_USED;                                              //报文块使用标志位置位
    
      rxBlock[i].message = (uint8_t*)Malloc((Len + 1) * sizeof(uint8_t));         //根据缓冲长度申请内存，多一个字节，用于填写字符串停止符
      
      memcpy(rxBlock[i].message, packet, Len);  
      
      rxBlock[i].message[Len] = 0;              // 添加结束符，该缓冲块可以用作字符串处理 
      
      rxBlock[i].length = Len; 
      
      return i;
      //break;
    }
  }
  
  if(i == RX_BLOCK_COUNT)
  { RxBlock_ErrorHandle(rxBlock, BlockFull); }
  
  return 0xFFFF;
}

/*********************************************************************************************

  * @brief  将缓冲内的数据填写到报文队列中
  * @param  rxBlockList：           接收缓冲结构体
  * @param  rxBlock：       报文接收块
  * @param  *f：         接收缓冲结构体
  * @retval 无
  * @remark 

  ********************************************************************************************/
void RxBlockListHandle(RxBlockTypeDef *rxBlock, void (*f)(uint8_t*, uint16_t))
{
  for(uint16_t i=0; i<RX_BLOCK_COUNT; i++)
  {
    if(rxBlock[i].flag & RX_FLAG_USED)                     //查找需要处理的报文
    {
      (*f)(rxBlock[i].message, rxBlock[i].length);
      
      Free(rxBlock[i].message);                             //释放申请的内存
    
      rxBlock[i].flag &= ~RX_FLAG_USED;                    //清空已使用标志位
    }
  }
}

/*********************************************************************************************
  * @brief  无线发送缓冲处理
  * @param  txBlock：发送缓冲块，发送缓冲队列头
  * @param  Transmit：发送函数指针（调用底层发送函数）
  * @param  interval：发送缓冲函数调用间隔时间
  * @retval 无
  * @remark 
  ********************************************************************************************/
void TxBlockListHandle(TxBlockTypeDef *txBlock, void (*Transmit)(uint8_t*, uint16_t), uint32_t interval)
{
  uint16_t i;
  static uint32_t time = 0;
  
  if((time + interval) > sysTime)
  { return; }
  else
  {  time = sysTime; }
  
  for(i=0; i<TX_BLOCK_COUNT; i++)
  {
      if(txBlock[i].flag & TX_FLAG_USED)            
      {
        
#ifdef TX_BLOCK_TIMEOUT
          /* 发送超时，进入错误处理，并释放发送缓冲块 */
          if((txBlock[i].time + TX_TIME_OUT) < sysTime && txBlock[i].flag & TX_FLAG_TIMEOUT)
          {
            TxBlockErrorHandle(TxBlockError_TimeOut);
            FreeTxBlock(&txBlock[i]);
            continue;
          }
#endif
        
          /*在已发送标志位为0，或者重复发送为真时
            进行数据的发送，并置位已发送标志位*/
          if(!(txBlock[i].flag & TX_FLAG_SENDED) || txBlock[i].flag & TX_FLAG_RT)
          {
            Transmit(txBlock[i].message, txBlock[i].length);             //发送数据
            txBlock[i].flag |= TX_FLAG_SENDED;
            //break;              //注意这个位置
          }
        
          txBlock[i].retransCounter ++;                            //重发次数递增
          
          /* 非手动清除 且 (重发超过200次 或者 不需要重发) 的情况下
             清除缓存释放模块 */
          if(!(txBlock[i].flag & TX_FLAG_MC) 
             && (txBlock[i].retransCounter > 200 || !(txBlock[i].flag & TX_FLAG_RT)))
          {
            FreeTxBlock(&txBlock[i]);
          }  
      }
  }
}

/*********************************************************************************************

  * @brief  填充发送结构体
  * @param  txBlock：发送模块结构体指针
  * @param  message：报文指针
  * @param  length：报文长度
  * @param  custom：自定义标志位，参考SimpleBuffer.h中的TX_FLAG
  * @return 
  * @remark 

  ********************************************************************************************/
uint16_t FillTxBlock(TxBlockTypeDef *txBlock, uint8_t *message, uint16_t length, uint8_t custom)
{
  uint16_t i;
  
  for(i=0; i<TX_BLOCK_COUNT; i++)
  { 
    if((txBlock[i].flag & TX_FLAG_USED) == 0)
    {
      txBlock[i].message = (uint8_t*)Malloc(length * sizeof(uint8_t));

      memcpy(txBlock[i].message, message, length);
      txBlock[i].length = length;
      txBlock[i].flag |= TX_FLAG_USED;
      
#ifdef TX_BLOCK_TIMEOUT
      txBlock[i].time = sysTime;
#endif
      
      /* 可以自定义标志位，自动添加占用标志位，默认只发送一次 */
      txBlock[i].flag |= custom;
      
      return i;
      //break;
    }
  }
  
  if(i == TX_BLOCK_COUNT)
  { TxBlock_ErrorHandle(txBlock, BlockFull); }
  
  return 0xFFFF;
}
/*********************************************************************************************

  * @brief  填充发送结构体
  * @param  txBlock：发送模块结构体指针
  * @param  message：报文指针
  * @param  length：报文长度
  * @param  custom：自定义标志位，参考SimpleBuffer.h中的TX_FLAG
  * @param  id：用于清除的标识
  * @return 
  * @remark 

  ********************************************************************************************/
uint16_t FillTxBlockWithId(TxBlockTypeDef *txBlock, uint8_t *message, uint16_t length, uint8_t custom, TX_ID_SIZE id)
{
  uint16_t blockId = FillTxBlock(txBlock, message, length, custom);
  
  if(blockId != 0xFFFF)
  { txBlock[blockId].id = id; }
  
  return blockId;
}
/*********************************************************************************************

  * @brief  释放发送缓冲
  * @param  txBlock：发送结构体指针
  * @return 
  * @remark 

  ********************************************************************************************/
void FreeTxBlock(TxBlockTypeDef *txBlock)
{
  Free(txBlock->message);
  
  txBlock->flag = 0;
  txBlock->length = 0;
  txBlock->retransCounter = 0;
  txBlock->id = 0;
  
#ifdef TX_BLOCK_TIMEOUT  
  txBlock->time = 0;
#endif
}

/*********************************************************************************************

  * @brief  通过自定义函数的方式清除相应发送缓冲块
  * @param  txBlock：发送结构体指针
            func，通过该func里的处理，将对应发送缓冲清除
            *p：自定义函数参数传递
  * @return 
  * @remark 

  ********************************************************************************************/
void FreeTxBlockByFunc(TxBlockTypeDef *txBlock, uint8_t (*func)(uint8_t*, uint16_t, void*), void *p)
{
  uint16_t i;
  
  for(i=0; i<TX_BLOCK_COUNT; i++)
  { 
    if((txBlock[i].flag & TX_FLAG_USED) != 0)
    {
      if(!func(txBlock[i].message, txBlock[i].length, p))
      { FreeTxBlock(txBlock + i); }
    }
  }
}
/*********************************************************************************************

  * @brief  清除指定发送缓冲
  * @param  txBlock：发送结构体指针
            id：通过自定义标识的方式释放发送缓冲
  * @return 
  * @remark 

  ********************************************************************************************/
void FreeTxBlockById(TxBlockTypeDef *txBlock, TX_ID_SIZE id)
{
  uint16_t i;
  
  for(i=0; i<TX_BLOCK_COUNT; i++)
  { 
    if((txBlock[i].flag & TX_FLAG_USED) != 0)
    {
      if(txBlock[i].id == id)
      { FreeTxBlock(txBlock + i); }
    }
  }
}
/*********************************************************************************************

  * @brief  判断数据包
  * @param  srcPacket：源数据包指针
  * @param  desPacket：目的数据包指针
  * @param  length：长度
  * @return 
  * @remark 判断数据包是否相同，相同为0，不同为1

  ********************************************************************************************/
uint8_t isPacketSame(uint8_t *srcPacket, uint8_t *desPacket, uint16_t length)
{
  uint16_t i = 0;
  for(i=0; i<length; i++)
  { 
    if(desPacket[i] != srcPacket[i])
    { break; } 
  }
  
  return (i==length)? 0 : 1;
}