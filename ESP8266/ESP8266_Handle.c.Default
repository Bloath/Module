/* Includes ------------------------------------------------------------------*/

#include "string.h"
#include "stdlib.h"
#include "Time.h"

#include "../UartDma/SimpleBuffer.h"
#include "../Common/Convert.h"
#include "../Common/Delay.h"
#include "../Common/Malloc.h"

#include "../ZcProtocol/Http.h"
#include "../ZcProtocol/ZcProtocol_Conf.h"

#include "ESP8266_HAL.h"
#include "ESP8266_Handle.h"


/* Private typedef -----------------------------------------------------------*/
typedef enum
{
  Error_ReceiveTimeout,
  Error_transmitTimeout,
  Error_CantConnectServer,
  Error_CipSendError,
  Error_TxBufferFull,
  Error_AirKissError
}ESP8266_Error;

typedef enum
{
  TxStatus_Idle,
  TxStatus_SendTxCmd,
  TxStatus_WaitCmdAck,
  TxStatus_SendData,
  TxStatus_WaitDataAck,
  TxStatus_WaitFinishAck,
}WifiTxStatus;

typedef enum
{
  TcpStatus_Init,
  TcpStatus_Connected,
  TcpStatus_StartTrans,
  TcpStatus_WaitAck,
  TcpStatus_SendOk
}ESP8266_TcpStatusEnum;


/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
ESP8266_ConnectStatusEnum ESP8266_ConnectStatus = ConnectStatus_Init;   //WIFI连接状态
ESP8266_TcpStatusEnum ESP8266_TcpStatus = TcpStatus_Init;               // TCP发送状态
uint16_t ESP8266_Status = 0;

TxQueueStruct Enthernet_TxQueue;                      //模块的发送缓冲
RxQueueStruct Enthernet_RxQueue;                      //模块的接收缓冲

/* Private function prototypes -----------------------------------------------*/
void ESP8266_SendAtCmd(uint8_t *data, uint16_t length);
void ESP8266_SendAtString(const char* cmd);

void ESP8266_ErrorHandle(ESP8266_Error errorType);
void ESP8266_HttpTransmit(uint8_t *message, uint16_t length);
void ESP8266_ResponseHandle(uint8_t *message, uint16_t length);

/* Private functions ---------------------------------------------------------*/

/*********************************************************************************************

  * @brief  ESP8266的接收处理函数
  * @param  data：需要发送的数据指针
  * @param  length：数据长度  
  * @retval 

  ********************************************************************************************/
void ESP8266_Handle()
{
  static uint32_t time = 0;
  
  switch(ESP8266_ConnectStatus)
  {
  case ConnectStatus_Init:      //初始化
    ESP8266_SendAtString("AT+CWMODE_DEF=1");
    ESP8266_SendAtString("AT+CWAUTOCONN=1");
    time = realTime;
    ESP8266_ConnectStatus = ConnectStatus_Idle;
    break;
  
  /****** 复位相关，如果复位则先发送复位，再等待2S后开UART ********/
  case ConnectStatus_Reset:
    ESP8266_HardWareReset();
    ESP8266_UART(FALSE);
    time = realTime;
    ESP8266_ConnectStatus = ConnectStatus_ResetWait;
    break;
    
  case ConnectStatus_ResetWait:
    if((time + 2) < realTime)
    { 
      ESP8266_UART(TRUE);
      time = realTime;
      ESP8266_ConnectStatus = ConnectStatus_Idle;
    }
  
  /********** 空闲状态、检查是否连接wifi ****************/
  case ConnectStatus_Idle:     
    if((time + ESP8266_INTERVAL) < realTime)
    { 
      ESP8266_SendAtString("AT+CWJAP?");
      time = realTime;
      ESP8266_ConnectStatus = ConnectStatus_WaitAck;
    }
    break;
  
  /***************** airkiss相关 **********************/
  case ConnectStatus_AirKiss:   //Airkiss
    ESP8266_SendAtString("AT+CWSTARTSMART=3");
    ESP8266_ConnectStatus = ConnectStatus_WaitAck;
    time = realTime;
    break;
    
  case ConnectStatus_AirKissWait:
    if((time + 20) < realTime)
    { 
      ESP8266_SendAtString("AT+CWSTOPSMART");
      ESP8266_ErrorHandle(Error_transmitTimeout);
    }
    break;
  
  /***************** 等待回复 **********************/
  case ConnectStatus_WaitAck:
    if((time + ESP8266_INTERVAL) < realTime)
    { ESP8266_ErrorHandle(Error_transmitTimeout);}
    break;
  
  /***************** 已连接 **********************/
  case ConnectStatus_Connected:
    TxQueue_Handle(&Enthernet_TxQueue, ESP8266_HttpTransmit, 300);
    break;
  }
}

/*********************************************************************************************

  * @brief  ESP8266的接收处理函数
  * @param  data：需要发送的数据指针
  * @param  length：数据长度  
  * @retval 

  ********************************************************************************************/
void ESP8266_HttpTransmit(uint8_t *message, uint16_t length)
{
  static uint32_t time = 0;
  char *count = NULL;
  
  switch(ESP8266_TcpStatus)
  { 
    /* 初始化，发送TCP连接，AT+CIPSTART="TCP","域名",80，等待模块回复CONNECT 或者 ALREADY CONNECTED */
  case TcpStatus_Init:          
    ESP8266_SendString("AT+CIPSTART=\"TCP\",\"");
#ifdef DOMAIN
    ESP8266_SendString(DOMAIN);
    ESP8266_SendString("\",80\r\n");
#else
    ESP8266_SendString(IP);
    ESP8266_SendString("\",");
    ESP8266_SendString(PORT);
    ESP8266_SendString("\r\n");
#endif
    ESP8266_TcpStatus = TcpStatus_WaitAck;
    time = realTime;
    break;
  
    /* 发送数据数量，先发送数据数量, AT+CIPSEND=数量，等待模块回复 > */
  case TcpStatus_Connected:     
    count = Uint2String((uint32_t)length);
    ESP8266_SendString("AT+CIPSEND=");
    ESP8266_SendString(count);
    ESP8266_SendString("\r\n");
    ESP8266_TcpStatus = TcpStatus_WaitAck;
    time = realTime;
    Free(count);
    break;
    
    /* 将数据写入模块，等待回复SEND OK */
  case TcpStatus_StartTrans:    //开始传输
    ESP8266_SendData(message, length);
    ESP8266_TcpStatus = TcpStatus_WaitAck;
    time = realTime;
    break;
  
  case TcpStatus_WaitAck:
    if((time + ESP8266_INTERVAL) < realTime)
    { ESP8266_ErrorHandle(Error_CipSendError); }        //等待超时错误处理，（AT指令发送数据后，长时间没回复）
    
    break;
    
    /* 当模块接收到回复数据时，会回复Recv xx bytes，切换为发送成功 */
  case TcpStatus_SendOk:
    ESP8266_TcpStatus = TcpStatus_Init;
    break;
  }
}

/*********************************************************************************************

  * @brief  ESP8266的接收处理函数
  * @param  data：需要发送的数据指针
  * @param  length：数据长度  
  * @retval 

  ********************************************************************************************/
void ESP8266_RxMsgHandle(uint8_t *packet, uint16_t length)
{
  char *message = (char *)packet;
  
  /***********airkiss部分****************/
  if(strstr(message, "AT+CWSTARTSMART=3") != NULL)
  {
    if(strstr(message,"ERROR") != NULL)
    { ESP8266_ErrorHandle(Error_AirKissError); }
    else
    { ESP8266_ConnectStatus = ConnectStatus_AirKissWait; }
  }
  
  if(strstr(message, "smartconfig connected") != NULL)  // smartconfig connected，则需要释放 AT+CWSTOPSMART
  { 
    ESP8266_SendAtString("AT+CWSTOPSMART"); 
    ESP8266_ConnectStatus = ConnectStatus_Idle;         // 连接成功，返回
    return; 
  }
  
  
  /***********连接wifi部分****************/
  /* 在模块上电时，接收到WIFI CONNECT时，不一定真正连接，必须通过CWJAP判断 */
  if(strstr(message, "CWJAP") != NULL)
  { 
    if(strstr(message, "No AP") == NULL)
    {
      ESP8266_ConnectStatus = ConnectStatus_Connected; 
      Enthernet_TxQueue.time = sysTime;           // 更新TCP发送队列时间，发送太快出问题
    }
    else
    { ESP8266_ConnectStatus = ConnectStatus_Idle; }
    return;
  }         

  /************错误ERROR处理************/
  if(strstr(message,"ERROR") != NULL)
  { 
    
     if(strstr(message, "CLOSED") != NULL)
    { ESP8266_ErrorHandle(Error_CantConnectServer); return; }
    
  }
  /**************TCP部分****************/
  
  if(strstr(message, "CLOSED") != NULL)                 //CLOSED 链接关闭
  { ESP8266_TcpStatus = TcpStatus_Init; return; }
    
  if(strstr(message, "CONNECT\r\n\r\nOK") != NULL ||
     strstr(message, "ALREADY CONNECTED") != NULL)            //CONNECT 连接成功
  { ESP8266_TcpStatus = TcpStatus_Connected; return; }
  
  if(strstr(message, "OK\r\n>") != NULL)                      // > 开始接收发送数据
  { ESP8266_TcpStatus = TcpStatus_StartTrans; return; }

  if(strstr(message, "SEND OK") != NULL)                   //SEND OK 发送成功
  { ESP8266_TcpStatus = TcpStatus_SendOk; }
  
  /***********收到数据处理****************/
  if(strstr(message, "+IPD") != NULL  || strstr(message, "+ID") != NULL)
  { 
    if(strstr(message, "HTTP") != NULL)                 //找到HTTP字符串
    { 
      char* index = (char *)Http_GetResponse(message);  //通过两次换行找到回复体
     
      if(index != NULL)
      { RxQueue_Add(&Enthernet_RxQueue, (uint8_t*)index, strlen(index)); }     // 回复体处理
    }
  }  

}

/*********************************************************************************************

  * @brief  向ESP8266发送命令,并向尾部增加一个换行字节
  * @param  data：需要发送的数据指针
  * @param  length：数据长度  
  * @retval 无
  * @remark 

  ********************************************************************************************/
void ESP8266_SendAtCmd(uint8_t *data, uint16_t length)
{
  uint8_t end[2] = {0x0D, 0x0A};
  ESP8266_SendData(data, length);       //发送数据
  ESP8266_SendData(end, 2);             //发送换行
}
/*********************************************************************************************

  * @brief  向ESP8266发送命令，可以直接填字符串
  * @param  cmd：命令字节
  * @retval 无
  * @remark 

  ********************************************************************************************/
void ESP8266_SendAtString(const char* cmd)
{
  ESP8266_SendAtCmd((uint8_t *)cmd, strlen(cmd));
}
/*********************************************************************************************

  * @brief  模块的错误处理
  * @param  errorType：错误类型
  * @return 
  * @remark 

  ********************************************************************************************/
void ESP8266_ErrorHandle(ESP8266_Error errorType)
{
  
  ESP8266_ConnectStatus = ConnectStatus_Reset;                                 //初始化连接
  ESP8266_TcpStatus = TcpStatus_Init;
  
  switch(errorType)
  {
    
  /* 连接服务器出错 */
  case Error_CantConnectServer:
    
    break;
    
  /* 接收超时 */
  case Error_ReceiveTimeout:
    
    break;
    
  /* 发送超时 */
  case Error_transmitTimeout:
    ESP8266_ConnectStatus = ConnectStatus_Init;                                 //初始化连接流程
    
    break;
    
  /* 启动发送时 */
  case Error_CipSendError:

    break;
    
  case Error_AirKissError:
    break;
    
  default:break;
  }
}
