/* Includes ------------------------------------------------------------------*/
#include "Module/Module.h"
#include "NB.h"
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
extern char *nbOcSet[];
extern struct TxQueueStruct debugTxQueue;
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/*********************************************************************************************

  * @brief  
  * @param   
  * @return 
  * @remark 

  ********************************************************************************************/
 void NB_OC_HandleBeforeNetting()
 {
    NB_SendATCommandList(nbOcSet);
 } 

/*********************************************************************************************

  * @brief  
  * @param   
  * @return 
  * @remark 

  ********************************************************************************************/
 void NB_OC_ReceiveHandle(char *message, uint16_t len)
 {   
    if (nb._process.last == Process_Start && strstr(message, "OK"))
    {   NB_SetProcess(Process_Run);    }
   
    // 接收到日期 -> 正式进入发送状态
    char *location = strstr(message, "+CCLK");
    if (location != NULL)
    {
        struct CalendarStruct calendar;
        calendar.year = 2000 + (location[6] - 0x30) * 10 + location[7] - 0x30;
        calendar.month = (location[9] - 0x30) * 10 + location[10] - 0x30;
        calendar.day = (location[12] - 0x30) * 10 + location[13] - 0x30;
        calendar.hour = (location[15] - 0x30) * 10 + location[16] - 0x30;
        calendar.min = (location[18] - 0x30) * 10 + location[19] - 0x30;
        calendar.sec = (location[21] - 0x30) * 10 + location[22] - 0x30;
        //uint8_t timeZone = (location[24] - 0x30) * 10 + location[25] - 0x30;
        TIMESTAMP = Calendar2TimeStamp(&calendar, 0);
    }
    
     // 接收到数据
    if (strstr(message, "+NNMI") != NULL)
    {
        nb._errorCounter = 0;

        char *tempPointer = (char *)message;
        bool isNeedCheck = false;
        for (uint8_t i = 0; i < 10; i++)
        {
            tempPointer = strstr(tempPointer, "+NNMI"); // 找到NMI
            if (tempPointer == NULL)
            {   break;  } // 没找到则直接退出

            /* 有可能发生字符串黏连的情况，则通过不同方式进行切割
               有换行符，则使用String_CutByChr，没有，则直接找到,后面字符作为指针 */
            char *msgStr = NULL;
            if (strstr(tempPointer, "\r") == NULL)
            {
                msgStr = (char *)((uint32_t)strstr(tempPointer, ",") + 1);
                isNeedCheck = false;
            }
            else
            {
                msgStr = String_CutByChr(tempPointer, ',', '\r');
                tempPointer = strstr(tempPointer, "\r");
                isNeedCheck = true;
            }
    
            // 收到AAA000,则清除最后一条回复
            //if(strstr(msgStr, "AAA000") != NULL)
            //{   TxQueue_FreeByFunc(nb.txQueueApp, Communicate_NbOCClearTxBlockFunction, &(nb.txQueueApp->_lastIndex)); }
            //else
            {
                uint8_t *msg = NULL;
                int count = HexString2Msg(&msg, msgStr + 10, 0);                    // 转换为字节数组格式
                if(count > 0)
                {   
                    RxQueue_Add(nb.rxQueueApp, msg, count, true);        // 填充到接收缓冲当中
                    
                    // 只有在抓换成功后，才回复确认
                    msgStr[1] = 0x33;
                    memset(msgStr + 6, 0x30, 4);
                    msgStr[10] = 0;
                    char *response = (char*)Malloc(32);
                    memset(response, 0, 32);
                    if(response != NULL)
                    {
                        sprintf(response, "AT+NMGS=5,%s\r\n", msgStr);
                        NB_StringTrans(response);
                        Free(response);
                    }
                }
            }
            Free(msgStr);
            
            if (isNeedCheck == false)
            {   break;  }
        }
    }
 }
/*********************************************************************************************

  * @brief  NB_DataPackage
  * @param  block
  * @retval 无
  * @remark -1 Malloc失败

  ********************************************************************************************/
int NB_OC_PacketPackage(struct TxBaseBlockStruct *block, struct PacketStruct *packet)//需要处理Malloc
{
    /* 申请内存
       AT+NMGS= 8位
       长度+逗号 4位
       \r\n 2位      */
    uint16_t totalLen = 40 + block->length * 4;
    char *msg = (char *)Malloc(totalLen);
    memset(msg, 0, totalLen);
    if(msg == NULL)
    {   return -1;  }
    
    if(block->length == 69)
    {   totalLen = 1;   }
    
    uint8_t prefix[3] = {1, (uint8_t)((block->length * 2) >> 8), (uint8_t)(block->length * 2)};
    
    /* 拼接指令协议 */
    sprintf(msg, "AT+NMGS=%d,", block->length * 2 + 3);
    Msg2HexString(msg + strlen(msg) + 1, prefix, 3);                                
    Msg2HexString(msg + strlen(msg) + 1, block->message, block->length);  // 填充报文
    strcat(msg, "\r\n");                                // 填充换行

    packet->data = (uint8_t *)msg;
    packet->length = strlen(msg);                       // 将打包好的数据指向packet，后面会自己free
    
    return 0;
}
/*********************************************************************************************

  * @brief  
  * @param   
  * @return 
  * @remark 

  ********************************************************************************************/
void NB_Http_StartConnect()
 {
    char *httpCreate = NULL;
    httpCreate = (char *)Malloc(64);
    memset(httpCreate, 0, 64);

    sprintf(httpCreate, "AT+HTTPCREATE=\"http://%s:%s/\"\r\n", nb.host, nb.port);
    NB_StringTrans(httpCreate);
    Free(httpCreate);
 } 
/*********************************************************************************************

  * @brief  
  * @param   
  * @return 
  * @remark 

  ********************************************************************************************/
void NB_HttpGet_ReceiveHandle(char *message, uint16_t len)
 {
   char *location = NULL, *temp = NULL;
   cJSON *json = NULL;
   
     // 是否正常打开SOCKET
    if (nb._process.last == Process_Start)
    {
        if(strstr(message, "ERROR"))
        {   NB_ErrorHandle(NBError_ConnectError);   }
        else
        {
            location = strstr(message, "\r\n\r\nOK\r\n");
            location -= 1;
            if( *location >= 30 && *location <= 0x39)
            {
                nb.socketId = *location - 0x30;
                NB_SetProcess(Process_Run);
                PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Init, REALTIME);
            }
            else
            {   NB_ErrorHandle(NBError_ConnectError);  }
        }
        return;
    }
    
    if(nb._process.last == Process_Run)
    {
        location = strstr(message, "OK");
        if(location != NULL)
        {
            NB_SetProcess(Process_Run);
            nb.http.__process.current = nb.http.__process.last;
            switch(nb.http.__process.current)
            {
            case Process_Init:
                PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Start, REALTIME);
                break;
            case Process_Start:
                PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Run, REALTIME); 
                break;
            case Process_Run:
                PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Wait, REALTIME);
                break;
            }
        }        
    }

    
    // 获取到内容则为+HTTPNMIC，获取到头则为+HTTPNMIH
    location = strstr(message, "+HTTPNMIC");
    if (location != NULL)
    {
        nb._errorCounter = 0;
        location = strstr(message, "\r\n{");
        location += 2;
            
        /* 回复body提取可用字符串 */
        if (location != NULL)
        {                 
            /* 找到换行符，将换行符改为结束符，再对报文进行转换 */
            temp = strstr(location, "}\r\n\r\n");
            if(temp != NULL)
            {   temp[1] = '\0';   }
            
            RxQueue_Add(nb.rxQueueApp, location, strlen(location), false);
        }     
        else
        {   NB_ErrorHandle(NbError_TxFail);   }
        return;
    }
 }
/*********************************************************************************************

  * @brief  NB_DataPackage
  * @param  block
  * @retval 无
  * @remark 

  ********************************************************************************************/
int NB_HttpGet_PacketPackage(struct TxBaseBlockStruct *block, struct PacketStruct *packet)//需要处理Malloc
{
    /* 申请内存
       AT+NMGS= 8位
       长度+逗号 4位
       \r\n 2位      */
    uint16_t totalLen = 40 + block->length * 2;
    char *msg = (char *)Malloc(totalLen);
    memset(msg, 0, totalLen);

    /* 拼接指令协议 */
    sprintf(msg, "AT+HTTPSEND=%d,0,/communication?message=", nb.socketId);
    Msg2String(msg + strlen(msg) + 1, block->message, block->length);     // 填充报文
    strcat(msg, "\r\n");                                // 填充换行

    packet->data = (uint8_t *)msg;
    packet->length = strlen(msg);                       // 将打包好的数据指向packet，后面会自己free
    
    return 0;
}
/*********************************************************************************************

  * @brief  NB_HttpPost_Transmit
  * @param  block
  * @retval 无
  * @remark 

  ********************************************************************************************/
#define SINGLE_TX_LENGTH    800
//#define TRANS_TX_QUEUE  (nb.txQueueHal)
//       
#define TRANS_WITH_DEBUG(message, len)                      \
    {                                                       \
        debugTxQueue.CallBack_Transmit(message, len);       \
        nb.txQueueHal->CallBack_Transmit(message, len);     \
    }
          
#define TRANS_TX_QUEUE  (&debugTxQueue)
bool NB_HttpPost_Transmit(struct TxBaseBlockStruct *txBlock)
{
    char stringTemp[200];
    
    /* 如果超了，则直接返回true */
    if(txBlock->currentIndex >= txBlock->length)
    {   return true;    }
    
    int end = 0;
    
    /* 判断长度，确认新end的位置 */
    if((txBlock->currentIndex + SINGLE_TX_LENGTH) > txBlock->length)
    {   end = txBlock->length;  }
    else
    {   end = txBlock->currentIndex + SINGLE_TX_LENGTH; }
    
    /* 调整位置，前后不能有逗号 */
    while(txBlock->message[end - 1] != ','
         && txBlock->message[end - 1] != '}')
    {   end += 1;   }
    
    switch(nb.http.__process.current)
    {
    case Process_Init:
        sprintf(stringTemp, "AT+HTTPHEADER=%d,\"%s\"\r\n", nb.socketId, nb.http.header);
        PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Wait, REALTIME);
        NB_StringTrans(stringTemp);
        break;
    case Process_Start:
        
        sprintf(stringTemp, "AT+HTTPCONTENT=%d,\"", nb.socketId);
        TRANS_WITH_DEBUG(stringTemp, strlen(stringTemp));
        
        /*  判断是否为分批发送
            1. 是分批发送，则按照id与总长度进行分批发送
            2. 不是分批发送，则拆分数据进行发送(不与at指令前导合并) */
        if(FLAG_IS_SET(txBlock->flag, TX_FLAG_IN_BATCHES))
        {   
            sprintf(stringTemp, "{'id':%d, 'messageType':'section', 'deviceId':'%s', 'totalLength':%d, 'contentLength': %d, 'start':%d, 'end':%d, 'content':\"", 
                    txBlock->id, 
                    DEVICE_ID,
                    txBlock->length, 
                    end - txBlock->currentIndex,
                    txBlock->currentIndex, 
                    end);
            TRANS_WITH_DEBUG(stringTemp, strlen(stringTemp));
            TRANS_WITH_DEBUG(txBlock->message + txBlock->currentIndex, end - txBlock->currentIndex); 
            TRANS_WITH_DEBUG("\"}", 2);
        }
        else
        {   TRANS_WITH_DEBUG(txBlock->message, txBlock->length );   }
        
        TRANS_WITH_DEBUG("\"\r\n", 3);
        PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Wait, REALTIME);
        break;
    case Process_Run:
        sprintf(stringTemp, "AT+HTTPSEND=%d,1,\"%s\"\r\n", nb.socketId, nb.http.url);
        NB_StringTrans(stringTemp);
        PROCESS_CHANGE_WITH_TIME(nb.http.__process, Process_Wait, REALTIME);
        break;
    case Process_Wait:
        if((nb.http.__process.__time + 5) < REALTIME)
        {   PROCESS_RETURN_WITH_TIME(nb.http.__process, REALTIME);  }
        break;
    }
    
    return false;
}
/*********************************************************************************************

  * @brief  
  * @param   
  * @return 
  * @remark 

  ********************************************************************************************/
void NB_HttpPost_ReceiveHandle(char *message, uint16_t len)
 {
   char *location = NULL, *temp = NULL;
   
     // 是否正常打开SOCKET
    if (nb._process.last == Process_Start)
    {
        if(strstr(message, "ERROR"))
        {   NB_ErrorHandle(NBError_ConnectError);   }
        else
        {
            location = strstr(message, "\r\n\r\nOK\r\n");
            location -= 1;
            if( *location >= 30 && *location <= 0x39)
            {
                nb.socketId = *location - 0x30;
                NB_SetProcess(Process_Run);
                PROCESS_CHANGE(nb.http.__process, Process_Init);
            }
            else
            {   NB_ErrorHandle(NBError_ConnectError);  }
        }
        return;
    }
    
    
    // 获取到内容则为+HTTPNMIC，获取到头则为+HTTPNMIH
    location = strstr(message, "+HTTPNMIC");
    if (location != NULL)
    {
        nb._errorCounter = 0;
        location = strstr(message, "\n68");
            
        /* 回复body提取可用字符串 */
        if (location != NULL)
        {   
            location += 1;                 
            
            /* 找到换行符，将换行符改为结束符，再对报文进行转换 */
            temp = strstr(location, "16\r\n");
            if(temp != NULL)
            {   temp[2] = '\0';   }
            
            uint8_t *packet = NULL;
            int count = String2Msg(&packet, location, 0);
            if (count > 0)
            {   RxQueue_Add(nb.rxQueueApp, packet, count, true);     }
        }     
        else
        {   NB_ErrorHandle(NbError_TxFail);   }
        return;
    }
    

 }